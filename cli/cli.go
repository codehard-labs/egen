package cli

import (
	"encoding/hex"
	"errors"
	"fmt"
	"log"
	"os"

	"github.com/codehard-labs/egen/core"
)

var (
	BasePath    = ".keys/"
	AESKeyPath  = BasePath + "aes/"
	EncPKeyPath = BasePath + "enc-pkey/"
)

func init() {
	makeDirIfNotExists(AESKeyPath)
}

func GenerateNewAESKey() {
	name, err := GetInput("Please name the new AES key [leave empty for random name]: \n", true)
	if err != nil {
		log.Fatal(err)
	}
	if name == "" {
		name = randomString(16)
	}
	aesKey := core.NewAESEncryptionKey()
	err = saveToLocalFileSafe(AESKeyPath, name+".key", hex.EncodeToString(aesKey))
	if err != nil {
		log.Fatal(err)
	}
}

func GenerateNewPkeyWithLocalAESKey(aesKeyName string) (string, string) {
	aesKeyName = getFromInputIfNil(aesKeyName, "Please insert name of the aes key: \n")
	addr, pkey, err := core.GenerateNewPkey()
	if err != nil {
		log.Fatal(err)
	}
	encPkey, err := core.AESEncrypt(pkey, readLocalAESKeyToBytes(aesKeyName))
	if err != nil {
		log.Fatal(err)
	}
	err = saveToLocalFileSafe(EncPKeyPath, aesKeyName+"-"+addr.Hex()+".key", hex.EncodeToString(encPkey))
	if err != nil {
		log.Fatal(err)
	}
	fmt.Printf(
		"New pkey is generated by AES key of the name: %s\nThe address of the pkey is: %s\nThe hex string of the enc-pkey is: %s\n",
		aesKeyName, addr.Hex(), hex.EncodeToString(encPkey),
	)
	return addr.Hex(), hex.EncodeToString(encPkey)
}

func VerifyLocalPkeyWithLocalAESKey(pkeyAddress, aesKeyName string) bool {
	// get arguments if nil
	pkeyAddress = getFromInputIfNil(pkeyAddress, "Please insert name of the enc-pkey: \n")
	aesKeyName = getFromInputIfNil(aesKeyName, "Please insert name of the aes key: \n")
	// read local hex string
	encPkey := readLocalEncPkeyToHexString(aesKeyName, pkeyAddress)
	aesKey := readLocalAESKeyToHexString(aesKeyName)
	pkey, err := core.DecryptPkey(encPkey, aesKey)
	if err != nil {
		log.Fatal(err)
	}
	addr, err := core.GetAddressFromPkey(pkey)
	if err != nil {
		log.Fatal(err)
	}
	return pkeyAddress == addr.Hex()
}

func DecryptPkeyWithLocalAESKey(hexEncPkey, aesKeyName string) ([]byte, error) {
	aesKeyName = getFromInputIfNil(aesKeyName, "Please insert name of the aes key: \n")
	return core.DecryptPkey(hexEncPkey, readLocalAESKeyToHexString(aesKeyName))
}

func saveToLocalFileSafe(path, fileName, content string) error {
	err := makeDirIfNotExists(path)
	if err != nil {
		return err
	}
	if fileExisted(path + fileName) {
		return errors.New("key file with the same name already exists")
	}
	f, err := os.Create(path + fileName)
	if err != nil {
		log.Println("heyhey", err)
		return err
	}
	_, err = f.WriteString(content)
	return err
}

func readLocalAESKeyToHexString(aesKeyName string) string {
	path := AESKeyPath + aesKeyName + ".key"
	aesKey, err := readLocalString(path)
	if err != nil {
		log.Fatal(err)
	}
	return aesKey
}

func readLocalAESKeyToBytes(aesKeyName string) []byte {
	path := AESKeyPath + aesKeyName + ".key"
	aesKey, err := readLocalBytes(path)
	if err != nil {
		log.Fatal(err)
	}
	return aesKey
}

func readLocalEncPkeyToHexString(aesKeyName, pkeyAddress string) string {
	path := EncPKeyPath + aesKeyName + "-" + pkeyAddress + ".key"
	encPkey, err := readLocalString(path)
	if err != nil {
		log.Fatal(err)
	}
	return encPkey
}

func getFromInputIfNil(a, cmdMsg string) string {
	if a != "" {
		return a
	}
	r, err := GetInput(cmdMsg, true)
	if err != nil {
		log.Fatal(err)
	}
	return r
}

func readLocalString(path string) (string, error) {
	c, err := os.ReadFile(path)
	if err != nil {
		return "", err
	}
	return string(c), nil
}

func readLocalBytes(path string) ([]byte, error) {
	c, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	cc, err := hex.DecodeString(string(c))
	if err != nil {
		return nil, err
	}
	return cc, nil
}
